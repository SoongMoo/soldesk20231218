# 커서
> for (i = 0; i < 100 ; i++){
	db.test.insertOne({"x" : i})
}
> var cursor= db.test.find()
> while (cursor.hasNext()){
	obj = cursor.next()
	print(obj.x)
}
> var cursor= db.test.find()
> cursor.forEach(function(obj){print(obj.x)})
> var cursor= db.users.find()
> cursor.forEach(function(obj){print(obj.age)})
> var cursor= db.test.find().sort({"x" : -1}).limit(10).skip(15)
> cursor.forEach(function(obj){print(obj.x)})

> var cursor= db.test.find().limit(10).sort({"x" : -1}).skip(15)
> cursor.forEach(function(obj){print(obj.x)})

> var cursor= db.test.find().skip(15).limit(10).sort({"x" : -1})
> cursor.forEach(function(obj){print(obj.x)})

# indexing
> db.test.drop()
> for (i = 0; i < 1000000 ; i++){
	db.test.insertOne({
		"i" : i,
		"username" : "user" + i,
		"age" : Math.floor(Math.random()*120),
		"created" : new Date()
	})
}

> db.test.find({"username" : "user101"}).explain("executionStats")
explain커서 메서드는 다양한 CRUD작업의 실행 정보를 제공한다.
executionStats는 인덱스를 이용한 쿼리 효과를 이해하도록 도와줌
executionTimeMillis 는 실행 시감을 ms로 표현: 0.936초

> db.test.createIndex({"username" : 1}) 
> db.test.find({"username" : "user101"}).explain("executionStats")
executionTimeMillis는 0.009초 걸린걸 확인 할 수 있다.
IXSCAN은 index를 이용했다는 것을 알 수 있다.

> db.test.find({"age" : 74}).explain("executionStats")
index가 없는 필드이므로 풀스캔을 해서 속도가 느리다.

# 복합 인덱스 :  여러개의 필드에 index를 사용
> db.test.find({"username" : "user101" , "age" : 47}).explain("executionStats")
"username"은 index가 있어서 index를 사용

> db.test.find({"age" : 47 , "username" : "user101"}).explain("executionStats")
select * from test
where age = 47 and username = "user101"

> db.test.createIndex({"age" : 1, "username" : 1})
> db.test.find({"age" : 21 , "username" : "user101"}) #index를 사용
select * from test
where age = 21 and username = 'user101'
> db.test.find({"age" : 21}).sort({"username" : -1})
select * from test
where age = 21
order by username desc
#  오라클에서 index는 where조건절에만 사용한다.

select * from test
where age >= 21 and age <= 30
> db.test.find({"age" : {"$gte" : 21 , "$lte" : 30}})
> db.test.find({"age" : {"$gte" : 21 , "$lte" : 30}}).explain("executionStats")
> db.test.find({"age" : {"$gte" : 21 , "$lte" : 30}}).sort({"username" : 1})
select * from test
where age >= 21 and age <= 30  # index 사용 :"age" : 1,"username" : 1
order by username asc

> db.students.insertOne({
    "_id": ObjectId(),
    "student_id": 0,
    "scores": [
       { "type": 'exam', 
        "score": 38.0500000060199827 },
       { "type": 'quiz', 
        "score": 79.4507499500898700 },
       { "type": 'homework', 
        "score": 74.5015054869953400 },
       { "type": 'homework', 
        "score": 74.6838168461584500 }
    ],
    "class_id" : 127
  })
select * from students
where class_id = 127
여기에 맞게 index를 만들어 보자
> db.students.find({ "class_id" : 127 })
> db.students.createIndex({"class_id" : 1})
> db.students.find({ "student_id" : 0 ,  "class_id" : 127 })
select * from students
where student_id = 0 and class_id = 127
> db.students.createIndex({"student_id" : 1, "class_id" : 1})

select * from students
where student_id < 500000 and  class_id = 127
order by  student_id asc
> db.students.find({"student_id " : {"$lt" : 500000} , "class_id " : 127}).sort({"student_id":1})
# 범위가 크면 index효과를 얻을 수없다.
# 검사하는 범위가 전체 크기에서 4 ~ 5% 미만인 경우에만 index를 만들어서 사용한다. 


{"student_id" : 1, "class_id" : 1}
{"student_id" : 1}, {"student_id" : 1, "class_id" : 1}

# index가 필요 없는 경우
select * from test
where i != 3
> db.test.find({"i" : {"$ne" : 3}})
$ne 또는 $not 은 컬렉션에 있는 모든 도큐먼트를 검사해야 하므로 index는 비효율적임

select * from test
where age = 47 and username > user5 and username  < user8
> db.test.find({"age": 47, "username": {"$gt": "user5","$lt": "user8"}})
> db.test.find({"age": 47, "username": {"$gt": "user5","$lt": "user8"}}).explain("executionStats")
select * from test
where username > user5 and username  < user8 and age = 47
> db.test.find({"username": {"$gt": "user5","$lt": "user8"}, "age": 47})
> db.test.find({"username": {"$gt": "user5","$lt": "user8"}, "age": 47}).explain("executionStats")

> db.foo.insertOne(
{ "_id" : ObjectId(), "apple" : 1, "banana" : 6, "peach" : 3 }
)
> db.foo.insertOne(
{ "_id" : ObjectId(), "apple" : 8, "spinach" : 4, "watermelon" : 4 }
)
> db.foo.find()

select * from foo
where apple = 8  # index
select * from foo
where banana = 6 # index

select * from foo
where apple = 8 or  banana = 6
> db.foo.find({"$or" : [{"apple" : 8}, {"banana" : 6}]})
{ "_id" : ObjectId("659e0a2f989d831b4fa858f0"), "apple" : 1, "banana" : 6, "peach" : 3 }
{ "_id" : ObjectId("659e0a34989d831b4fa858f1"), "apple" : 8, "spinach" : 4, "watermelon" : 4 }

> db.foo.find({"apple" : 1, "banana" : 6})
select * from foo
where apple = 1 and banana = 6
{ "_id" : ObjectId("659e0a2f989d831b4fa858f0"), "apple" : 1, "banana" : 6, "peach" : 3 }

> db.foo.find({"$or" : [{"apple" : 8}, {"banana" : 6}]}).explain("executionStats")
> db.foo.find({"apple" : 1, "banana" : 6}).explain("executionStats")

> db.foo.createIndex({"apple" : 1})
> db.foo.createIndex({"banana" : 1})
> db.foo.find({"$or" : [{"apple" : 8}, {"banana" : 6}]}).explain("executionStats")
# 각 조건마다 하나씩 index를 사용한다.
> db.foo.find({"$or" : [{"banana" : 6} , {"apple" : 8} ]}).explain("executionStats")

select * from foo
where apple = 1 or apple = 8
> db.foo.find({"$or" : [{"apple" : 1}, {"apple" : 8}]})
> db.foo.find({"$or" : [{"apple" : 1}, {"apple" : 8}]}).explain("executionStats")

select * from foo
where apple in (1, 8)
> db.foo.find({"apple" : {"$in" : [1, 8]}})
> db.foo.find({"apple" : {"$in" : [1, 8]}}).explain("executionStats")

# 내장 도큐먼트 index
> db.students.findOne()
> db.students.find({"scores.score" : 79.45074995008987 })
> db.students.find({"scores.score" : 79.45074995008987 }).explain("executionStats")

### 
> db.students.createIndex({"scores.score" : 1})
### 권장함, index를 사용한다.
> db.students.find({"scores.score" : 79.45074995008987 })
> db.students.find({"scores.score" : 79.45074995008987 }).explain("executionStats")


> db.students.findOne()
### 권장하지 않음 , index를 사용하지 않음
> db.students.find({"scores"  : {"type" : "exam" , "score" : 38.050000006019985}})
> db.students.find({"scores"  : {"type" : "exam" , "score" : 38.050000006019985}}).explain("executionStats")

> db.students.findOne({"scores.score" : 79.45074995008987 })
> db.students.findOne({"scores.score" : 100.000000000000 })

# 요소번호에 해당되는 값이 있는 것만 출력
> db.students.findOne({"scores.2.score" : 74.50150548699534 })
2는 배열의 요소번호 (요소번호는 0번 부터 시작
> db.students.findOne({"scores.3.score" : 74.50150548699534 })
null
3는 배열의 요소번호
> db.students.find({"scores.score" : 79.45074995008987 }).explain("executionStats")
# index사용
> db.students.find({"scores.2.score":74.50150548699534}).explain("executionStats")
# 내부도규먼트에  index를 만들어 줘도  배열의 요소번호를 사용할 경우 index를 사용하지 못함.
# index에는 배열의 요소번호를 포함하고 있지 않다.

# 배열 인덱싱 : 배열의 요소번호를 포함하는 index를 만들자.
> db.students.createIndex({"scores.2.score" : 1})
# 배열의 요소번호 2번에 index를 만들어 줌.
> db.students.find({"scores.2.score":74.50150548699534}).explain("executionStats")
# index를 사용한다.
> db.students.findOne({"scores.3.score" : 74.68381684615845 })
> db.students.find({"scores.3.score" : 74.68381684615845 }).explain("executionStats")

# 집계: 일치, 선출, 정렬, 건너뛰기, 제한
> db.companies.insertOne(
{"_id" : ObjectId(),
  "name" : "Facebook",
  "category_code" : "social",
  "founded_year" : 2004,
  "description" : "Social network",
  "funding_rounds" : [{
    "id":4,
    "round_code" : "b",
    "raised_amount" : 27500000,
    "raised_currency_code" : "USD",
    "funded_year" : 2006,
    "investments" : [{
        "compony" : null,
        "financial_org" : {
            "name" : "Greylock Partners",
            "permalink" : "greylock"
        },
        "person" : null
    },{
        "compony" : null,
        "financial_org" : {
            "name" : "Meritech Capital Partners",
            "permalink" : "meritech-capital-partners"
        },
        "person" : null
    },{
        "compony" : null,
        "financial_org" : {
            "name" : "Founders Fund",
            "permalink" : "founders-fund"
        },
        "person" : null
    },{
        "compony" : null,
        "financial_org" : {
            "name" : "SV Angel",
            "permalink" : "sv-angel"
        },
        "person" : null
    }
]} 
,{
    "id":2197,
    "round_code" : "c",
    "raised_amount" : 15000000,
    "raised_currency_code" : "USD",
    "funded_year" : 2008,
    "investments" : [{
        "compony" : null,
        "financial_org" : {
            "name" : "European Founders Fund",
            "permalink" : "european-founders-fund"
        },
        "person" : null
    }
  ]
  }],
"ipo" : {
    "valuation_amount" : NumberLong("1040000000000"),
    "valuation_currency_code" : "USD",
    "pub_year" : 2012,
    "pub_month" : 5,
    "pub_day" : 18,
    "stock_symbol" : "NASDAQ:F8"
}}
)
> db.companies.findOne()

# 일치 : $match
# 설립년도가 2004인 모든 회사를 출력하시오.
select * from companies
where founded_year = 2004

> db.companies.find({"founded_year" : 2004})
> db.companies.aggregate([{  $match : { "founded_year" : 2004} } ])

select name, founded_year  from companies
where founded_year = 2004
> db.companies.find({"founded_year" : 2004} , {"name": 1 , "founded_year" : 1 , "_id" : 0 })
> db.companies.aggregate([{  $match : { "founded_year" : 2004} },
		           { $project  : {
				_id : 0,
				name : 1,
				founded_year : 1	
		           }}	
 ])

select rownum , name, founded_year  from companies
where founded_year = 2004 and rownum < 3
> db.companies.find({"founded_year" : 2004} , {"name": 1 , "founded_year" : 1 , "_id" : 0 }).limit(3)
> db.companies.aggregate([{  $match : { "founded_year" : 2004} },
		           { $project  : {
				_id : 0,
				name : 1,
				founded_year : 1	
		           }}	,
		           {$limit : 2}
 ])
> db.companies.aggregate([{  $match : { "founded_year" : 2004} },
		           {$limit : 2},
		           { $project  : {
				_id : 0,
				name : 1,
				founded_year : 1	
		           }}	
		           
 ])
select rownum , name, founded_year  from companies
where founded_year = 2004 and rownum < 3
oreder by name asc
> db.companies.find({"founded_year" : 2004}, {"name": 1 , "founded_year" : 1 , "_id" : 0 }).limit(3).sort({"name" : 1})
> db.companies.aggregate([{  $match : { "founded_year" : 2004} },
		           {$limit : 2},
		           {$sort : {name : 1}},
		           { $project  : {
				_id : 0,
				name : 1,
				founded_year : 1	
		           }}	
		           
 ])
먼저 정렬하고 10개의 도큐먼트는 건너뛰고 5개만 출력
> db.companies.find({"founded_year" : 2004}, {"name": 1 , "founded_year" : 1 , "_id" : 0 }).limit(5).sort({"name" : 1}).skip(10)
> db.companies.aggregate([{  $match : { "founded_year" : 2004} },
		           {$limit : 2},
		           {$skip : 10},
		           {$sort : {name : 1}},
		           { $project  : {
				_id : 0,
				name : 1,
				founded_year : 1	
		           }}	
		           
 ])

# founded_rounds필드에 있는 서브 도큐먼트에 있는 investments필드에 있는 도규먼트에 financial_org필드가 있고
financial_org필드에 있는 도규먼트에 있는 permalink필드의 값이 greylock인 것을 출력하시오
이때 name , ipo.pub_year ,  ipo.valuation_amount, funding_rounds.investments.financial_org.permalink 출력
findOne이용하기


> db.companies.find({"funding_rounds.investments.financial_org.permalink" : "greylock"}, 
		 {"name": 1 ,"ipo.pub_year" : 1,  "ipo.valuation_amount" : 1, 
		  "funding_rounds.investments.financial_org.permalink" : 1 , "_id" : 0})
